<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docs on Golang Tutorial</title>
    <link>https://hopher.github.io/golang-tutorial/docs/</link>
    <description>Recent content in Docs on Golang Tutorial</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 09 Apr 2019 21:38:06 +0800</lastBuildDate>
    
	<atom:link href="https://hopher.github.io/golang-tutorial/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>The Latest Cool</title>
      <link>https://hopher.github.io/golang-tutorial/docs/20190409213806/</link>
      <pubDate>Tue, 09 Apr 2019 21:38:06 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/20190409213806/</guid>
      <description></description>
    </item>
    
    <item>
      <title>21-并发</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213444/</link>
      <pubDate>Tue, 09 Apr 2019 21:34:44 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213444/</guid>
      <description></description>
    </item>
    
    <item>
      <title>20-错误处理</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213433/</link>
      <pubDate>Tue, 09 Apr 2019 21:34:33 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213433/</guid>
      <description></description>
    </item>
    
    <item>
      <title>19-类型转换</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213425/</link>
      <pubDate>Tue, 09 Apr 2019 21:34:25 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213425/</guid>
      <description></description>
    </item>
    
    <item>
      <title>18-递归函数</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213416/</link>
      <pubDate>Tue, 09 Apr 2019 21:34:16 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213416/</guid>
      <description></description>
    </item>
    
    <item>
      <title>17-Map</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213408/</link>
      <pubDate>Tue, 09 Apr 2019 21:34:08 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213408/</guid>
      <description></description>
    </item>
    
    <item>
      <title>16-范围</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213357/</link>
      <pubDate>Tue, 09 Apr 2019 21:33:57 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213357/</guid>
      <description></description>
    </item>
    
    <item>
      <title>15-切片</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213349/</link>
      <pubDate>Tue, 09 Apr 2019 21:33:49 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213349/</guid>
      <description>切片 切片扩容时，会重新建立新的底层数组，内存重新分配内存储存空间, 然后把旧的数据复制到新的数组里, 时间复杂度O(n) 切片长度 &amp;gt;= 1024时, 以1.25倍进行扩容, 小于1024时则2倍扩容
golang 官方文档在关于 slice 的 append 一节有说明： &amp;gt; If the capacity of s is not large enough to fit the additional values, append allocates a new, sufficiently large underlying array that fits both the existing slice elements and the additional values. Otherwise, append re-uses the underlying array.
也就是说，如果原来的底层数组足够大，能放的下 append 的数据，就不会新建底层数组。而如果不够的话，则会分配一个新的数组。也因此是 O(n) 的时间复杂度</description>
    </item>
    
    <item>
      <title>14-结构体</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213340/</link>
      <pubDate>Tue, 09 Apr 2019 21:33:40 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213340/</guid>
      <description> 结构体 </description>
    </item>
    
    <item>
      <title>13-指针</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213329/</link>
      <pubDate>Tue, 09 Apr 2019 21:33:29 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213329/</guid>
      <description> 指针 指针，返回的是内存地址空间 (十六进制)
格式：0xc000070010, 开头的“0”令解析器更易辨认数，而“x”则代表十六进制
 二进制 数据在计算机中的表示，最终是以二进制的形式存在 - 优点：更直观地解决 - 缺点：太长，不容易思考，可以用更短的16进制表示
 指针一般用 ptr 表示
package main import &amp;quot;fmt&amp;quot; func main() { var a int = 10 fmt.Printf(&amp;quot;变量的地址: %v\n&amp;quot;, &amp;amp;a ) fmt.Printf(&amp;quot;变量的地址: %#x\n&amp;quot;, &amp;amp;a ) }  </description>
    </item>
    
    <item>
      <title>12-数组</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213320/</link>
      <pubDate>Tue, 09 Apr 2019 21:33:20 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213320/</guid>
      <description>数组 数组声明
var balance [10] float32  初始化数组
 [&amp;hellip;] 为不定长
 var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0} var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}  访问数组元素
var salary float32 = balance[9]  示例：
package main import &amp;quot;fmt&amp;quot; func main() { var n [10]int /* n 是一个长度为 10 的数组 */ var i,j int /* 为数组 n 初始化元素 */ for i = 0; i &amp;lt; 10; i++ { n[i] = i + 100 /* 设置元素为 i + 100 */ } /* 输出每个数组元素的值 */ for j = 0; j &amp;lt; 10; j++ { fmt.</description>
    </item>
    
    <item>
      <title>11-变量作用域</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213311/</link>
      <pubDate>Tue, 09 Apr 2019 21:33:11 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213311/</guid>
      <description>3种变量作用域  局部变量
作用域只在函数体内 全局变量
全局变量可以在整个包 &amp;amp;&amp;amp; 外部包（被导出后）使用 &amp;gt; 外部包引用，变量要大写
import &amp;quot;outside&amp;quot; fmt.Printf(&amp;quot;%s&amp;quot;, outside.Name)  形式参数 形式参数会作为函数的局部变量来使用。
示例
package main import &amp;quot;fmt&amp;quot; /* 声明全局变量 */ var a int = 20; func main() { /* main 函数中声明局部变量 */ var a int = 10 var b int = 20 var c int = 0 fmt.Printf(&amp;quot;main()函数中 a = %d\n&amp;quot;, a); c = sum( a, b); fmt.Printf(&amp;quot;main()函数中 c = %d\n&amp;quot;, c); } /* 函数定义-两数相加 */ func sum(a, b int) int { fmt.</description>
    </item>
    
    <item>
      <title>10-函数</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213305/</link>
      <pubDate>Tue, 09 Apr 2019 21:33:05 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213305/</guid>
      <description> 闭包 package main import &amp;quot;fmt&amp;quot; func getSequence() func() int { i:=0 return func() int { i+=1 return i } } func main(){ /* nextNumber 为一个函数，函数 i 为 0 */ nextNumber := getSequence() /* 调用 nextNumber 函数，i 变量自增 1 并返回 */ fmt.Println(nextNumber()) fmt.Println(nextNumber()) fmt.Println(nextNumber()) /* 创建新的函数 nextNumber1，并查看结果 */ nextNumber1 := getSequence() fmt.Println(nextNumber1()) fmt.Println(nextNumber1()) }  正规函数 /* 函数返回两个数的最大值 */ func max(num1, num2 int) int { /* 声明局部变量 */ var result int if (num1 &amp;gt; num2) { result = num1 } else { result = num2 } return result }  </description>
    </item>
    
    <item>
      <title>09-循环语句</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213258/</link>
      <pubDate>Tue, 09 Apr 2019 21:32:58 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213258/</guid>
      <description></description>
    </item>
    
    <item>
      <title>08-条件语句</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213249/</link>
      <pubDate>Tue, 09 Apr 2019 21:32:49 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213249/</guid>
      <description></description>
    </item>
    
    <item>
      <title>07-运算符</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213241/</link>
      <pubDate>Tue, 09 Apr 2019 21:32:41 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213241/</guid>
      <description> 运算符  算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 其他运算符  </description>
    </item>
    
    <item>
      <title>06-常量</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213234/</link>
      <pubDate>Tue, 09 Apr 2019 21:32:34 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213234/</guid>
      <description> 常量 格式：
const identifier [type] = value  [type] 可以省略，使用直行推断
示例:
const b string = &amp;quot;abc&amp;quot; const b = &amp;quot;abc&amp;quot;  多个相同类型的声明, 简写
const c_name1, c_name2 = value1, value2  </description>
    </item>
    
    <item>
      <title>05-变量</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213225/</link>
      <pubDate>Tue, 09 Apr 2019 21:32:25 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213225/</guid>
      <description> 3种变量声明方式  无初始化, 指定变量类型 var 类型推断 短变量声明 :=  </description>
    </item>
    
    <item>
      <title>04-数据类型</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213215/</link>
      <pubDate>Tue, 09 Apr 2019 21:32:15 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213215/</guid>
      <description>table th:first-of-type { width: 60px; } 
数据类型    序号 类型和描述     1 布尔型 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。   2 数字类型 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。   3 字符串类型: 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。   4 派生类型:
(a) 指针类型（Pointer）
(b) 数组类型
(c) 结构化类型(struct)
(d) Channel 类型
(e) 函数类型
(f) 切片类型
(g) 接口类型（interface)
(h) Map 类型    数字类型 Go 也有基于架构的类型，例如：int、uint 和 uintptr。</description>
    </item>
    
    <item>
      <title>03-基础语法</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213205/</link>
      <pubDate>Tue, 09 Apr 2019 21:32:05 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213205/</guid>
      <description> 基础语法  25 个关键字或保留字 36 个预定义标识符  </description>
    </item>
    
    <item>
      <title>02-语言结构</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213157/</link>
      <pubDate>Tue, 09 Apr 2019 21:31:57 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213157/</guid>
      <description></description>
    </item>
    
    <item>
      <title>01-安装</title>
      <link>https://hopher.github.io/golang-tutorial/docs/base/20190409213147/</link>
      <pubDate>Tue, 09 Apr 2019 21:31:47 +0800</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/base/20190409213147/</guid>
      <description> 安装 docker-compose 安装 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hopher.github.io/golang-tutorial/docs/A1/A01-xx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/A1/A01-xx/</guid>
      <description>Go语言fmt包Printf方法详解 General  %v 以默认的方式打印变量的值 %T 打印变量的类型  Integer  %+d 带符号的整型，fmt.Printf(&amp;quot;%+d&amp;quot;, 255)输出+255 %q 打印单引号 %o 不带零的八进制 %#o 带零的八进制 %x 小写的十六进制 %X 大写的十六进制 %#x 带0x的十六进制 %U 打印Unicode字符 %#U 打印带字符的Unicode %b 打印整型的二进制  Integer width  %5d 表示该整型最大长度是5，下面这段代码
fmt.Printf(&amp;quot;|%5d|&amp;quot;, 1) fmt.Printf(&amp;quot;|%5d|&amp;quot;, 1234567)  输出结果如下：
| 1| |1234567|  %-5d则相反，打印结果会自动左对齐
 %05d会在数字前面补零。
  Float  %f (=%.6f) 6位小数点 %e (=%.6e) 6位小数点（科学计数法） %g 用最少的数字来表示 %.3g 最多3位数字来表示 %.3f 最多3位小数来表示  String  %s 正常输出字符串 %q 字符串带双引号，字符串中的引号带转义符 %#q 字符串带反引号，如果字符串内有反引号，就用双引号代替 %x 将字符串转换为小写的16进制格式 %X 将字符串转换为大写的16进制格式 % x 带空格的16进制格式  String Width (以5做例子）  %5s 最小宽度为5 %-5s 最小宽度为5（左对齐） %.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hopher.github.io/golang-tutorial/docs/20190409205253/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hopher.github.io/golang-tutorial/docs/20190409205253/</guid>
      <description>Caput vino delphine in tamen vias Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.
 Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  Natus quaerere Pectora et sine mulcere, coniuge dum tincta incurvae.</description>
    </item>
    
  </channel>
</rss>